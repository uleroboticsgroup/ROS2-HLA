hla:
  federation_name: "RoboticsFed"
  federate_name: "ClientBridge_Controller"
  fom_file_path: "/home/vicen/ISDEFE/ros2_hla_ws/src/ROS2HLA_Bridge/examples/turtlebot4_gazebo/fom/robotics.xml"
  pitch_jar_path: "/home/vicen/prti1516e/lib/prti1516e.jar"

time_management:
  is_regulating: false
  is_constrained: true
  time_step: 0.1
  lookahead: 0.1

# ROS2 -> HLA (Client sends commands)
# We will have a local node publishing to /turtlebot4_control/cmd_vel and the bridge sends it to HLA
ros_to_hla:
  - ros_topic: "/turtlebot4_control/cmd_vel"
    ros_type: "geometry_msgs.msg.TwistStamped"
    hla_interaction_class: "Control"
    mapping:
      twist.linear.x: "linearVel"
      twist.angular.z: "angularVel"
    fixed_parameters:
      robotName: "TurtleBot4"

ros_actions:
  - ros_action: "/client/undock" # Exposed to client
    ros_type: "irobot_create_msgs.action.Undock"
    hla_goal_interaction: "UndockGoal"
    hla_result_interaction: "UndockResult"
    mapping:
      goal: {}
      result:
        is_docked: "isDocked"
    fixed_parameters:
      robotName: "TurtleBot4"

# HLA -> ROS2 (Client receives pose/odom from HLA)
# The bridge receives updates for 'Robot' object and publishes to /turtlebot4_control/odom_monitor
hla_to_ros:
  - ros_topic: "/turtlebot4_control/odom_monitor"
    ros_type: "nav_msgs.msg.Odometry"
    hla_object_class: "Robot"
    hla_instance_name: "TurtleBot4"
    mapping:
      pose.pose.position.x: "positionX"
      pose.pose.position.y: "positionY"
